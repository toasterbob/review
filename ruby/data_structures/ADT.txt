Data structures - array, hash, string

Abstract Data Type (ADT)

- set
  include?, << (shovel), delete
  can't include duplicates
  you can implement a set with a hash map - value could equal true
  inserting into a set when something exists, nothing happens

- map / dictionary
  set (key, value), get (k), delete(k)
  map is just a set of key value pairs

- stack
  two operations: push and pop
  LIFO
  things on top are the most recent
  stack of cafeteria trays being wet
  not fair
  use an array with only push and pop. implements a stack.
  STACK IS USED DURING RECURSION
  implicit in any recursive algorithm

- queue
  enqueue and dequeue
  FIFO
  totally fair
  push(for enqueue) and shift(dequeue)
  or unshift(for enqueue) and pop (dequeue)

- tree
  most common type is a binary tree
  parent/child relationship
  called binary tree because each node (or vertex) has at most two children
  every node has at most one parent (it can have no parents)
  single node is a tree
  empty tree is still a tree
  directionality to a tree

  ternary tree
  every node has at most, three children

  unary tree - one child
  linked list

  n-ary tree (polytree)
  can have many children

  top of the tree is called the root
  the tree is rooted at this node

  very bottom layer are the leaves (leaf nodes)

  A is the parent of B and C.
  The subtree rooted at B has children D and E

  The depth/height of the tree - how many layers
  Tree traversal - how do we traverse a tree?

  BFS - breadth first search (layer by layer) 1, 2, 3, 4, 5, 6, 7
  DFS - depth first search () 4, 5, 2, 6, 7, 3, 1
        1
      2   3
    4  5 6  7

  DFS looks for leaves first - BFS searches top first - If you know something
  is more likely to be at the bottom or top, it affects your decision

  BFS - use a queue  = [root]
  until queue.empty?
    el = queue.shift
    process!(el)
    el.children.each{|child| queue << child}
  end

  
